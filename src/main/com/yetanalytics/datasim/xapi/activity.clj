(ns com.yetanalytics.datasim.xapi.activity
  (:require [clojure.spec.alpha :as s]
            [clojure.string :as cs]
            [clojure.walk :as w]
            [xapi-schema.spec :as xs]
            [com.yetanalytics.datasim.input :as input]
            [com.yetanalytics.datasim.iri :as iri]
            [com.yetanalytics.datasim.random :as random]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Specs
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(s/def :cosmos/activity-type
  iri/iri-spec)

(s/def :cosmos.activity-type/activity-id
  iri/iri-spec)

;; the total cosmos of activities in the sim.
(s/def ::cosmos
  (s/map-of :cosmos/activity-type
            (s/map-of :cosmos.activity-type/activity-id
                      ::xs/activity)))

(s/def :derive-cosmos/seed
  int?)

;; minimum possible activities per type
;; TODO: take a map so this can be customized from params
(s/def :derive-cosmos.options/min-per-type
  pos-int?)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Derive Activity Cosmos
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn- profile-activity-type-iris
  "Get all Activity Types IDs used across Profiles, including both ActivityType
   Concepts and mentions in Statement Templates."
  [profiles]
  (let [concepts  (mapcat :concepts profiles)
        templates (mapcat :templates profiles)
        ;; Activity Type colls
        template->activity-types
        (fn [{:keys [objectActivityType rules] :as _template}]
          (cond->> (for [{:keys [location any all]} rules
                         :when (= location "$.object.definition.type")
                         iri (concat any all)]
                     iri)
            objectActivityType
            (cons objectActivityType)))
        concept-activity-types
        (->> concepts
             (filter (comp #{"ActivityType"} :type))
             (map :id))
        template-actiivty-types
        (->> templates
             (mapcat template->activity-types))]
    (into #{} (concat concept-activity-types template-actiivty-types))))

(defn- profile-activities
  "Return a comsos of Activities supplied from `profiles`; the value
   returned is a map of the form
   ```
   {activity-type {activity-id activity}}
   ```
   where `activity` has values for `id` and `definition` properties based
   on the Activity definition from the `profiles`."
  [profiles]
  (let [concepts (mapcat :concepts profiles)]
    (->> concepts
         (filter
          (comp (partial = "Activity") :type))
         (reduce
          (fn [m {id :id
                  {activity-type :type :as activity-def} :activityDefinition}]
            (assoc-in m
                      [activity-type id]
                      {"id"         id
                       "definition" (w/stringify-keys
                                     (dissoc activity-def :_context))}))
          {}))))

(defn- generate-activities
  "Return a vector of `[activity-id activity]` pairs, where `activity-id` is
   autogenerated based on the `activity-type-iri`. The number of pairs
   returned is `(- min-per-type type-count)` (where type here referrs to
   Activity Types)."
  [rng-delay min-per-type type-count type-iri]
  (for [_ (range (- min-per-type type-count))
        :let [;; make a possibly familiar little tag if we can
              tag         (or (re-matches #"[a-zA-Z0-9]*"
                                          (last (cs/split type-iri #"/")))
                              "activity")
              serial      (random/rand-int* @rng-delay Integer/MAX_VALUE)
              activity-id (format "https://example.org/%s/%d" tag serial)]]
    [activity-id {"id"         activity-id
                  "definition" {"type" type-iri}}]))

(s/fdef derive-cosmos
  :args (s/cat :input :com.yetanalytics.datasim/input
               :seed :derive-cosmos/seed
               :options (s/keys* :opt-un [:derive-cosmos.options/min-per-type]))
  :ret ::cosmos)

(defn derive-cosmos
  "Given a datasim input with a `profiles` value and a `seed`, derive a cosmos
   of activities. Takes a seed to generate additional Activities not specified.
   `min-per-type` dictates the minimum number of Activities per Activity Type
   that are generated. Returns an
   ```
   {activity-type-id {activity-id activity}}
   ```
   where `activity` is minimal and consists of the generated \"id\" and
   \"definition\".
   "
  [{:keys [profiles]}
   seed
   & {:keys [min-per-type]
      :or   {min-per-type 1}}]
  (let [all-activity-type-iris   (profile-activity-type-iris profiles)
        supplied-activity-cosmos (profile-activities profiles)
        ;; This is a delay in case we do not need it; this way we only need
        ;; to init it when necessary.
        rng-delay      (delay (random/seed-rng seed))
        gen-activities (partial generate-activities rng-delay min-per-type)]
    (reduce
     (fn [cosmos activity-type-iri]
       (let [type-count (count (get cosmos activity-type-iri))]
         (if (<= min-per-type type-count)
           cosmos
           (->> (gen-activities type-count activity-type-iri)
                (update cosmos activity-type-iri (fnil into {}))))))
     supplied-activity-cosmos
     all-activity-type-iris)))

(comment
  (require '[clojure.pprint :as pprint])
  (def i (input/from-location :input :json "dev-resources/input/simple.json"))


  (pprint/pprint (derive-cosmos i 42 :min-per-type 3))



  )
